'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var remark = require('remark');
var html = require('remark-html');
var shiki = require('shiki');
var escapeGoat = require('escape-goat');
var remarkAutolinkHeadings = require('remark-autolink-headings');
var remarkGfm = require('remark-gfm');
var remarkSlug = require('remark-slug');
var visit = require('unist-util-visit');
var rangeParser = require('parse-numeric-range');
var path = require('path-browserify');
var toc = require('mdast-util-toc');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var remark__default = /*#__PURE__*/_interopDefaultLegacy(remark);
var html__default = /*#__PURE__*/_interopDefaultLegacy(html);
var remarkAutolinkHeadings__default = /*#__PURE__*/_interopDefaultLegacy(remarkAutolinkHeadings);
var remarkGfm__default = /*#__PURE__*/_interopDefaultLegacy(remarkGfm);
var remarkSlug__default = /*#__PURE__*/_interopDefaultLegacy(remarkSlug);
var visit__default = /*#__PURE__*/_interopDefaultLegacy(visit);
var rangeParser__default = /*#__PURE__*/_interopDefaultLegacy(rangeParser);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var toc__default = /*#__PURE__*/_interopDefaultLegacy(toc);

/*!
 * Adapted from
 * - ggoodman/nostalgie
 *   - MIT https://github.com/ggoodman/nostalgie/blob/45f3f6356684287a214dab667064ec9776def933/LICENSE
 *   - https://github.com/ggoodman/nostalgie/blob/45f3f6356684287a214dab667064ec9776def933/src/worker/mdxCompiler.ts
 */
shiki.setCDN("https://unpkg.com/@ryanflorence/md@3.0.5/");
function getProcessor(options = {}) {
    return remark__default['default']()
        .use(tocPlugin)
        .use(stripLinkExtPlugin, options)
        .use(remarkCodeBlocksShiki)
        .use(remarkGfm__default['default'])
        .use(remarkSlug__default['default'])
        .use(remarkAutolinkHeadings__default['default'])
        .use(html__default['default']);
}
async function processMarkdown(content, options) {
    let processor = getProcessor(options);
    let result = await processor.process(content);
    return result.contents;
}
////////////////////////////////////////////////////////////////////////////////
let highlighter;
////////////////////////////////////////////////////////////////////////////////
// cache it so the browser doesn't keep fetching it on typing
let base16Theme;
async function loadBase16() {
    if (base16Theme)
        return base16Theme;
    if (typeof window !== "undefined") {
        base16Theme = await shiki.loadTheme("dist/base16.json");
        return base16Theme;
    }
    else {
        return shiki.loadTheme(path__default['default'].resolve(__dirname, "base16.json"));
    }
}
let remarkCodeBlocksShiki = () => {
    return async function transformer(tree) {
        let theme = await loadBase16();
        let langs = [
            "js",
            "json",
            "jsx",
            "ts",
            "tsx",
            "markdown",
            "shellscript",
            "html",
            "css",
            "diff",
            "mdx",
            "prisma",
        ];
        let langSet = new Set(langs);
        highlighter =
            highlighter || (await shiki.getHighlighter({ themes: [theme], langs }));
        let themeName = "base16";
        visit__default['default'](tree, "code", (node) => {
            var _a, _b;
            if (!node.lang || !node.value || !langSet.has(node.lang)) {
                return;
            }
            // TODO: figure out how this is ever an array?
            let meta = Array.isArray(node.meta) ? node.meta[0] : node.meta;
            let metaParams = new URLSearchParams();
            if (meta) {
                let linesHighlightsMetaShorthand = meta.match(/^\[(.+)\]$/);
                if (linesHighlightsMetaShorthand) {
                    metaParams.set("lines", linesHighlightsMetaShorthand[0]);
                }
                else {
                    metaParams = new URLSearchParams(meta.split(/\s+/).join("&"));
                }
            }
            let language = node.lang;
            let highlightLines = parseLineHighlights(metaParams.get("lines"));
            let numbers = !metaParams.has("nonumber");
            let fgColor = convertFakeHexToCustomProp(highlighter.getForegroundColor(themeName) || "");
            let bgColor = convertFakeHexToCustomProp(highlighter.getBackgroundColor(themeName) || "");
            let tokens = highlighter.codeToThemedTokens(node.value, language, themeName);
            let children = tokens.map((lineTokens, zeroBasedLineNumber) => {
                let children = lineTokens.map((token) => {
                    let color = convertFakeHexToCustomProp(token.color || "");
                    let content = {
                        type: "text",
                        // Do not escape the _actual_ content
                        value: token.content,
                    };
                    return color && color !== fgColor
                        ? {
                            type: "element",
                            tagName: "span",
                            properties: {
                                style: `color: ${escapeGoat.htmlEscape(color)}`,
                            },
                            children: [content],
                        }
                        : content;
                });
                children.push({
                    type: "text",
                    value: "\n",
                });
                return {
                    type: "element",
                    tagName: "span",
                    properties: {
                        className: "codeblock-line",
                        dataHighlight: (highlightLines === null || highlightLines === void 0 ? void 0 : highlightLines.includes(zeroBasedLineNumber + 1)) ? "true"
                            : undefined,
                        dataLineNumber: zeroBasedLineNumber + 1,
                    },
                    children,
                };
            });
            let metaProps = {};
            metaParams.forEach((val, key) => {
                if (key === "lines")
                    return;
                metaProps[`data-${key}`] = val;
            });
            let nodeValue = {
                type: "element",
                tagName: "pre",
                properties: {
                    ...metaProps,
                    dataLineNumbers: numbers ? "true" : "false",
                    dataLang: escapeGoat.htmlEscape(language),
                    style: `color: ${escapeGoat.htmlEscape(fgColor)};background-color: ${escapeGoat.htmlEscape(bgColor)}`,
                },
                children: [
                    {
                        type: "element",
                        tagName: "code",
                        children,
                    },
                ],
            };
            let data = (_a = node.data) !== null && _a !== void 0 ? _a : (node.data = {});
            node.type = "element";
            (_b = data.hProperties) !== null && _b !== void 0 ? _b : (data.hProperties = {});
            data.hChildren = [nodeValue];
            return visit.SKIP;
        });
    };
};
////////////////////////////////////////////////////////////////////////////////
let parseLineHighlights = (param) => {
    if (!param)
        return [];
    let range = param.match(/^\[(.+)\]$/);
    if (!range)
        return [];
    return rangeParser__default['default'](range[1]);
};
// The theme actually stores #FFFF${base-16-color-id} because vscode-textmate
// requires colors to be valid hex codes, if they aren't, it changes them to a
// default, so this is a mega hack to trick it.
function convertFakeHexToCustomProp(color) {
    return color.replace(/^#FFFF(.+)/, "var(--base$1)");
}
// Kinda weird hack, should probably copy/modify mdhast-util-doc but this just
// replace any heading with `## toc` in it with the toc
let tocPlugin = () => {
    return function (node) {
        if (node.children.length === 0) {
            return {
                type: "root",
                children: [],
            };
        }
        let first = node.children[0];
        if (first.type === "heading" && first.children[0].value === "toc") {
            let result = toc__default['default'](node, { heading: "toc" });
            // remove the `## toc` placeholder
            node.children.splice(0, 1);
            // nothing to TOC about (get it?!)
            if (!result.map) {
                return getWrapper(false, node.children);
            }
            result.map.data = { hProperties: { class: "toc" } };
            return getWrapper(result.map, node.children);
        }
        else {
            return {
                type: "root",
                children: [
                    {
                        type: "element",
                        data: {
                            hProperties: {
                                class: "md-prose",
                            },
                        },
                        children: node.children,
                    },
                ],
            };
        }
    };
};
let stripLinkExtPlugin = (settings) => {
    let options = settings; // no idea how remark wants me to type this.
    return function (tree) {
        visit__default['default'](tree, "link", (node, index, parent) => {
            if (options.resolveHref &&
                typeof node.url === "string" &&
                isRelativeUrl(node.url)) {
                if (parent) {
                    parent.children[index] = {
                        ...node,
                        url: options.resolveHref(node.url),
                    };
                    return visit.SKIP;
                }
            }
        });
    };
};
function isRelativeUrl(test) {
    // Probably fragile but should work well enough.
    // It would be nice if the consumer could provide a baseURI we could do
    // something like:
    // new URL(baseURI).origin === new URL(test, baseURI).origin
    let regexp = new RegExp("^(?:[a-z]+:)?//", "i");
    return !regexp.test(test);
}
function getWrapper(toc, children) {
    return {
        type: "root",
        children: [
            {
                type: "element",
                data: {
                    hProperties: {
                        class: "md-toc-container",
                    },
                },
                children: [
                    {
                        type: "element",
                        data: {
                            hProperties: {
                                class: "md-toc-nav",
                                role: "navigation",
                            },
                        },
                        children: [toc].filter(Boolean),
                    },
                    {
                        type: "element",
                        data: {
                            hProperties: {
                                class: "md-prose",
                            },
                        },
                        children,
                    },
                ],
            },
        ],
    };
}

Object.defineProperty(exports, 'setCDN', {
  enumerable: true,
  get: function () {
    return shiki.setCDN;
  }
});
exports.getProcessor = getProcessor;
exports.processMarkdown = processMarkdown;
exports.remarkCodeBlocksShiki = remarkCodeBlocksShiki;
