"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.remarkCodeBlocksShiki = exports.addTrailingSlash = exports.removeTrailingSlash = exports.removeLeadingSlash = exports.isIndexPath = exports.cleanMarkdownPath = exports.resolveUrl = exports.isRelativeUrl = exports.getCurrentUrl = exports.processMarkdown = void 0;
const tslib_1 = require("tslib");
const url_1 = require("url");
const md_1 = require("@ryanflorence/md");
const tiny_invariant_1 = (0, tslib_1.__importDefault)(require("tiny-invariant"));
async function reactRouterProcessMarkdown(baseUrl, content, opts) {
    var _a;
    let preserveLinks = (_a = opts.preserveLinks) !== null && _a !== void 0 ? _a : false;
    return (0, md_1.processMarkdown)(content, {
        resolveHref(sourceHref) {
            if (opts.resolveHref) {
                let resolved = opts.resolveHref(sourceHref);
                if (resolved !== false) {
                    return resolved;
                }
            }
            if (preserveLinks ||
                !isRelativeUrl(sourceHref) ||
                sourceHref.startsWith("#") ||
                sourceHref.startsWith("?")) {
                return sourceHref;
            }
            let currentUrl = getCurrentUrl(baseUrl, opts.linkOriginPath);
            let currentUrlIsIndex = isIndexPath(opts.linkOriginPath);
            let href = cleanMarkdownPath(sourceHref);
            try {
                let from = addTrailingSlash(currentUrl.origin + currentUrl.pathname);
                let to = href.startsWith("/") || currentUrlIsIndex ? href : `../${href}`;
                let resolved = resolveUrl(from, to);
                return resolved.pathname + resolved.search + resolved.hash;
            }
            catch (error) {
            }
            return href;
        },
    });
}
exports.processMarkdown = reactRouterProcessMarkdown;
function getCurrentUrl(baseUrl, pathFromServer) {
    (0, tiny_invariant_1.default)(pathFromServer, "Resolving the current URL depends on a source path when called from the server.");
    let withNoTrailingSlash = removeTrailingSlash(pathFromServer);
    let withLeadingSlash = removeLeadingSlash(withNoTrailingSlash);
    let toPath = cleanMarkdownPath(withLeadingSlash);
    return resolveUrl(baseUrl.origin, toPath);
}
exports.getCurrentUrl = getCurrentUrl;
function isRelativeUrl(test) {
    let regexp = new RegExp("^((?:[a-z]+:)?//|mailto:|tel:)", "i");
    return !regexp.test(test);
}
exports.isRelativeUrl = isRelativeUrl;
function resolveUrl(from, to) {
    try {
        let resolvedUrl = new url_1.URL(to, new url_1.URL(from, "resolve://"));
        if (resolvedUrl.protocol === "resolve:") {
            let { pathname, search, hash } = resolvedUrl;
            return new url_1.URL(pathname + search + hash);
        }
        return resolvedUrl;
    }
    catch (error) {
        if (error instanceof TypeError &&
            error.toString() === "TypeError: Failed to construct 'URL': Invalid URL") {
            throw TypeError("Failed to resolve URL. The `from` argument is an invalid URL.");
        }
        throw error;
    }
}
exports.resolveUrl = resolveUrl;
function cleanMarkdownPath(str) {
    let regex = /((\/index)?\.md$|(\/index)?\.md(#))/;
    if (regex.test(str)) {
        return str.replace(regex, "$4");
    }
    return str;
}
exports.cleanMarkdownPath = cleanMarkdownPath;
function isIndexPath(str) {
    if (!str)
        return false;
    let regex = /(\/index(\.md)?$|\/index(\.md)?(#))/;
    return regex.test(removeLeadingSlash(removeTrailingSlash(str)));
}
exports.isIndexPath = isIndexPath;
function removeLeadingSlash(str) {
    return str.replace(/^\/+/, "");
}
exports.removeLeadingSlash = removeLeadingSlash;
function removeTrailingSlash(str) {
    return str.replace(/\/+$/, "");
}
exports.removeTrailingSlash = removeTrailingSlash;
function addTrailingSlash(str) {
    return removeTrailingSlash(str) + "/";
}
exports.addTrailingSlash = addTrailingSlash;
var md_2 = require("@ryanflorence/md");
Object.defineProperty(exports, "remarkCodeBlocksShiki", { enumerable: true, get: function () { return md_2.remarkCodeBlocksShiki; } });
